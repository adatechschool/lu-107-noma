# Comprendre

Essayez de synthétiser en binôme votre compréhension de la notion que vous avez vue (s'il s'agissait de plusieurs notions, vous pouvez répéter ce paragraphe plusieurs fois) : POO

# Quel est son rôle ? 
=> paradigme de programmation informatique 
=> ensemble d'objets qui interagissent entre eux

# Quel est son intérêt ? 
- Organiser le code : chaque classe a ses propres prorietes
- Ameliorer sa lisibilite
- Faciliter sa reutilisation
- Reguler l'acces/modification des donnees via private/public
- Reduire la complexite du code : less is more !!!!

# A-t-elle des désavantages ? 
- Parfois plus simple de faire une fonction que de creer un objet => pas adapte pour toutes les tailles de projet
- Impact du polymorphisme sur le temps d'execution du code
- Conception et organisation a reflechir/definir en amont => danger d' "overengineering"
- Prevoir plus de documentations pour l'utilisation du code

# Y a-t-il plusieurs façons de s'en servir ? 
Selon les langages, l'utilisation n'est pas la meme.

# Quelles sont les étapes importantes pour la mettre en place ? 
- Definir les classes
- Instancier les classes pour creer des objets avec le constructeur

# Quelles sont les nuances d'un langage à l'autre ? 

# Existe-t-il des contextes (langages, environnements, outils) où elle n'existe pas ? 
POO : les langages de programmation (chronologiquement : Simula, LOGO, Smalltalk, Ada, C++, Objective C, Eiffel, Python, PHP, Java, Ruby, AS3, C#, VB.NET, Vala, Haxe, Swift)
Pas POO : Pascal, C

# Quelles sont ses alternatives ? 
- Programmation imperative (paradigme originel = le processeur execute une serie d'instructions) -> Sous ensemble = programmation structuree (evite les GOTO) -> Programmation procedurale = procedures qui regroupent une serie d'etapes a realiser
- Programmation declarative, sous emsemble -> fonctionnelle = utilise les fonctions mathemathiques, rejette le changement d'etat et la mutation des donnees
- Programmation concurrente = plusieurs piles semantiques (thread, processus ou cache)
